package by.spontaneous.bluetoothchat;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.UUID;

import android.app.Service;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.Intent;
import android.os.Binder;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.os.Messenger;
import android.os.ParcelUuid;
import android.os.RemoteException;
import android.util.Log;
import android.widget.Toast;

public class ChatClientService extends Service implements IChatClient
{
	public class LocalBinder extends Binder
	{
		ChatClientService getService()
		{
			return ChatClientService.this;
		}
	}
	private final IBinder mBinder = new LocalBinder();
	@Override
	public IBinder onBind(Intent intent)
	{
		return mBinder;
	}

	/** Messenger взаимодействия с GUI. */
	private Messenger messenger;

	/** Socket связи с сервером. */
	private BluetoothSocket socket;

	/** Thread клиентского ожидания новых сообщений от сервера. */
	private ConnectedThread connectedThread;

	/** Цель подключения; Device-сервер. */
	private BluetoothDevice device;

	/** Реализация интерфейса чата (клиент / сервер). */
	private IChatClient altChatClient;

	@Override
	public void onCreate()
	{
		// TODO Auto-generated method stub
		super.onCreate();

		Toast.makeText(getBaseContext(), "ChatClientService onCreate()", Toast.LENGTH_LONG).show();
	}

	@Override
	public void onDestroy()
	{
		super.onDestroy();

		disconnect();

		Toast.makeText(getBaseContext(), "ChatClientService onDestroy()", Toast.LENGTH_LONG).show();
	}

	/**
	 * Устанавливает реализацию интерфейса взаимодействия с сервисом в
	 * соответствии с запущенным режимом.
	 */
	public void setChatClient(IChatClient chatClient)
	{
		altChatClient = chatClient;
	}

	/**
	 * Возвращает реализацию интерфейса взаимодействия с сервисом в соответствии
	 * с запущенным режимом.
	 */
	public IChatClient getChatClient()
	{
		if (altChatClient != null)
		{
			return altChatClient;
		}

		return this;
	}

	/** Инициализация ChatClientService целевым BluetoothDevice. */
	public void init(BluetoothDevice blueDevice)
	{
		// TODO: этот механизм проверки режима работы приложения (клиент/сервер)
		// нужно упростить...
		// Предотвращение ошибки в случае запуска клиента после сервера
		if (blueDevice != null)
		{
			altChatClient = null;
		}

		device = blueDevice;
	}

	public void disconnect()
	{
		if (connectedThread != null)
		{
			connectedThread.cancel();
			connectedThread = null;

			try
			{
				if (socket != null)
				{
					socket.close();
				}
			}
			catch (IOException e)
			{
				Toast.makeText(getBaseContext(), "Ошибка ChatClientService: " + e.getMessage(), Toast.LENGTH_LONG)
						.show();
			}

			// TODO: ошибка от 07.08.16 посиделки с Игнатом
			// Это ещё зачем?!
			// ...метод disconnect() используется при подключении к серверу...
			// ...инициализация device происходит только при передаче управления
			// от
			// MainActivity к ChatActivity...
			// ...device = null на данный момент допустим только для работы в
			// режиме
			// сервера...
			messenger = null;
		}
	}

	/**
	 * Метод, позволяющий определить, в каком режиме сейчас находится сервис
	 * ChatClientService.
	 */
	public boolean IsMaster()
	{
		return device == null ? true : false;
	}

	/**
	 * Класс потока клиента, принимающего сообщения от сервера, к которому он
	 * подключен.
	 */
	private class ConnectedThread extends Thread
	{
		private final BluetoothSocket mmSocket;
		private final InputStream mmInStream;
		private final OutputStream mmOutStream;

		public ConnectedThread(BluetoothSocket socket)
		{
			mmSocket = socket;
			InputStream tmpIn = null;
			OutputStream tmpOut = null;

			// Get the input and output streams, using temp objects because
			// member streams are final
			try
			{
				tmpIn = socket.getInputStream();
				tmpOut = socket.getOutputStream();
			}
			catch (IOException e)
			{
				obtainToast("ChatClientService: ошибка BluetoothSocket.get...Stream: " + e.getMessage());
			}

			mmInStream = tmpIn;
			mmOutStream = tmpOut;
		}

		public void run()
		{
			byte[] buffer = new byte[256]; // buffer store for the stream
			int bytes; // bytes returned from read()

			// buffer[0] = (byte) MessageCode.MESSAGE_READ.getId();
			// write(buffer);

			// Keep listening to the InputStream until an exception occurs
			while (true)
			{
				try
				{
					// Read from the InputStream
					bytes = mmInStream.read(buffer);

					if (bytes == 65356)
					{
						// Log.e(CLIENT_DEBUG_TAG, "mmInStream.read(buffer) ==
						// -1");
						break;
					}

					// Log.d(CLIENT_DEBUG_TAG, "MyBuffer content: " + new
					// String(buffer, 1, bytes) );

					// Send the obtained bytes to the UI activity
					// mHandler.obtainMessage( (int) buffer[0], bytes, -1,
					// buffer).sendToTarget();
					obtainMessage(buffer);
				}
				catch (IOException e)
				{
					obtainToast("ChatClientService: ошибка while (true){...} " + e.getMessage());
					break;
				}
			}

			obtainToast("Client - ConnectedThread: run() завершён!");
		}

		/* Call this from the main activity to send data to the remote device */
		public void write(byte[] bytes)
		{
			try
			{
				mmOutStream.write(bytes);
			}
			catch (IOException e)
			{
				obtainToast("Client - ConnectedThread: " + e.getMessage());
			}
		}

		/* Call this from the main activity to shutdown the connection */
		public void cancel()
		{
			try
			{
				mmSocket.close();
				obtainToast("Client - ConnectedThread: успешно закрыт!");
			}
			catch (IOException e)
			{
				obtainToast("Client - ConnectedThread: ошибка закрытия! " + e.getMessage());
			}
		}
	}

	private void obtainToast(String str)
	{
		try
		{
			Message msg = Message.obtain(null, 0, 0, 0);

			msg.obj = str;

			messenger.send(msg);
		}
		catch (RemoteException e)
		{

		}
	}

	private void obtainMessage(byte[] buffer)
	{
		try
		{
			Message msg = Message.obtain(null, 1, 0, 0);

			msg.obj = buffer;

			messenger.send(msg);
		}
		catch (RemoteException e)
		{

		}
	}
	
	// Client-реализация IChatClient для ChatActivity
	/**
	 * Client-реализация одного из методов интерфейса IChatClient, отвечающего
	 * за создание потока связи с приложением, запущенном в режиме Server.
	 * Возврат false закрывает ChatActivity при попытке подключения к
	 * ChatClientService.
	 */
	@Override
	public boolean connectToServer(Messenger selectedMessenger)
	{
		disconnect();

		if (selectedMessenger == null)
		{
			Toast.makeText(getBaseContext(), "Ошибка ChatClientService: provider == null", Toast.LENGTH_LONG).show();
			return false;
		}

		try
		{
			// MY_UUID is the app's UUID string, also used by the server
			// code
			ParcelUuid[] uuids = device.getUuids();

			UUID myid = UUID.fromString(getResources().getString(R.string.service_uuid));

			/*
			 * boolean is_contained = false;
			 * 
			 * for (ParcelUuid uuid : uuids) {
			 * //Toast.makeText(getBaseContext(), uuid.getUuid().toString(),
			 * Toast.LENGTH_LONG).show(); if (uuid.getUuid() == myid) {
			 * is_contained = true; break; } }
			 * 
			 * if (is_contained == false) { Toast.makeText(getBaseContext(),
			 * "SDP-сервис не найден!", Toast.LENGTH_LONG).show(); return false;
			 * }
			 */
			socket = device.createRfcommSocketToServiceRecord(myid);

			socket.connect();
		}
		catch (IOException e)
		{
			// Основная ошибка здесь: попытка подключения к устройству, на
			// котором не поднят нужный сервис Service Discovery Protocol (SDP)
			Toast.makeText(getBaseContext(), e.getLocalizedMessage(), Toast.LENGTH_LONG).show();
			// disconnect();
			return false;
		}

		// TODO: равен самому себе что ли?
		// ...теоретически ссылка на самого себя...
		messenger = selectedMessenger;

		connectedThread = new ConnectedThread(socket);
		connectedThread.start();

		return true;
	}

	@Override
	public void sendMessage(String str)
	{
		OutputStream outStream = null;

		try
		{
			outStream = socket.getOutputStream();
			outStream.write(str.getBytes());
		}
		catch (IOException e)
		{
			Toast.makeText(getBaseContext(), "ChatClientService: ошибка sendMessage(String str):" + e.getMessage(),
					Toast.LENGTH_LONG).show();
		}
	}

	@Override
	public void close()
	{
		disconnect();
	}
}